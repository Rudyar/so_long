Transformer les png en .xml

 // Checker si ac = 2
// checker .ber & .ber a la fin !!
 Checker si .ber no null
Calculer combien de lignes (calculer les \n ?)
Calculer longueure ligne 1
Calculer le nombre de P C E et X


--------------------------------------------------------------------------------------------

		count = read(fd, buff, 1);
		if (count < 0)
			break ;
		if (buff[0] != '\n' && buff[0] != '\0')
			map->lines[i] = ft_strjoin(map->lines[i], buff);
		else
			i++;







#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 800
#define RED_PIXEL 0xFF0000
#define WHITE_COLOR 0xfffafa

// typedef struct s_img
// {
// 	void	*mlx_img;
// 	char	*addr;
// 	int		bpp; /* bits per pixel */
// 	int		line_len;
// 	int		endian;
// }	t_img;

typedef struct s_mlx
{
	void	*mlx;
	void	*win;
	void	*img;
}	t_mlx;

int	key_press(int keycode, t_mlx *data)
{
	if (keycode == XK_Escape)
		mlx_destroy_window(data->mlx, data->win);
	return (0);
}

void	render_background(t_mlx *data, int color)
{
	int	i;
	int	j;

	if (data->win == NULL)
		return ;
	i = 0;
	while (i < WINDOW_HEIGHT)
	{
		j = 0;
		while (j < WINDOW_WIDTH)
			mlx_pixel_put(data->mlx, data->win, j++, i, color);
		++i;
	}
}

int	render(t_mlx *data)
{
	(void)data;
	render_background(data, WHITE_COLOR);
	mlx_put_image_to_window(data->mlx, data->win, data->img, 100, 50);
	return (0);
}

int	main(void)
{
	t_mlx	data;
	int	i = 500;
	int	j = 500;

	data.mlx = mlx_init();
	data.win = mlx_new_window(data.mlx, 1920, 1080, "Yoyo");
	data.img = mlx_xpm_file_to_image(data.mlx, "srcs/assets/enemy_01.xpm", &i, &j);
	// render(&data);
	mlx_loop_hook(data.mlx, &render, &data);
	mlx_hook(data.win, KeyPress, KeyPressMask, &key_press, &data);
	mlx_loop(data.mlx);
	mlx_destroy_display(data.mlx);
	free(data.mlx);
	return (0);
}





#include "../../so_long.h"

void	check_input(char *input)
{
	if (ft_strlen(input) == 0)
		exit(EXIT_FAILURE);
	if (!ft_strnstr(input, ".ber", ft_strlen(input)))
		exit(EXIT_FAILURE);
}

void	parse_input(t_map *map, char *input)
{
	// int		i;
	// int		count;
	// int		fd;
	// char	buff[2];
	(void)map;
	// i = 0;
	// count = 1;
	// fd = 1;
	// buff[1] = '\0';
	check_input(input);
	// fd = open(input, O_RDONLY);
}
